# Как звучит само задание к третьему уроку:
* Опишите схему события в формате json schema для любого формального и функционального события.
На выходе у вас должно получиться две схемы. Если не хотите использовать json schema, можно взять avro.

* Опишите процесс миграции четырёх связей. Если у вас нет связи с нужным условием, можно пропустить описание миграции:

1. Переход формальной синхронной на асинхронную event-driven.
2. Переход формальной асинхронной event-driven на синхронную.
3. Переход функциональной синхронной на асинхронную event-driven.
4. Переход функциональной асинхронной event-driven на синхронную.

* UPDATED. В данном задании достаточно просто описать шаги. Рисунки рисовать не надо и описывать зачем делать каждый из шагов.
Хватит простого списка из N шагов где будет описано что и в каком сервисе делается.

* UPDATED. Опишите процесс миграции одной формальной и одной функциональной связи для новых требований бизнеса.
Стартовой точкой миграции стоит считать уже исправленную связь, т.е. если вы решили использовать формальную event-driven коммуникацию для передачи заданий
— описывайте миграцию на новое требование сразу с асинхронной на асинхронную связь.

* По итогу должно получиться два описания, одно для формальной или функцинальной связи касающейся [US-160] и одно для [US-170] (какую связь для какого требования выбрать — решайте на свое усмотрение).

* В данном задании достаточно просто описать шаги. Рисунки рисовать не надо и описывать зачем делать каждый из шагов.
Хватит простого списка из N шагов где будет описано что и в каком сервисе делается.

* Подготовить описание способов решения проблем вокруг зачисления и списания средств, так как бизнес переживает что что-то пойдет не так и деньги потеряются.
Нужно составить список подходов, которые помогут не потерять данные, объяснить почему именно эти подходы нужны и как будут обрабатываться ошибки в случае проблем.


# Решение
## Схема события в формате json:

  * В качестве формальной связи возьмем стриминг кандидата из найма в менеджмент:

```
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "CandidateCreated",
  "description": "Событие, описывающее создание кандидата в одном сервисе и передачу его данных в другой",
  "type": "object",
  "required": [
    "candidate_id",
    "candidate_name",
    "created_at",
    "status"
  ],
  "properties": {
    "candidate_id": {
      "type": "string",
      "title": "Candidate ID",
      "description": "Уникальный идентификатор кандидата"
    },
    "candidate_name": {
      "type": "string",
      "title": "Candidate Name",
      "description": "Полное имя кандидата"
    },
    "created_at": {
      "type": "string",
      "format": "date-time",
      "title": "Created At",
      "description": "Дата и время создания кандидата"
    },
    "status": {
      "type": "string",
      "enum": ["candidate", "teacher"],
      "title": "Status",
      "description": "Роль пользователя в системе"
    },
    "exercises_to_solve": {
      "type": "array",
      "title": "Exercises To Solve",
      "description": "Список упражнений, назначенных кандидату",
      "items": {
        "type": "object",
        "required": ["exercise_id"],
        "properties": {
          "exercise_id": {
            "type": "string",
            "title": "Exercise ID",
            "description": "Уникальный идентификатор задания"
          }
        }
      },
      "default": []
    }
  }
}
```


  * В качестве функцональной связи возьмем бизнес событие что задание выполнили более 10 раз из найма в менеджмент

```
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "ExerciseCompletedMoreThenTenTimes",
  "description": "Событие, когда упражнение выполнено более десяти раз кандидатом",
  "type": "object",
  "required": [
    "event_id",
    "event_version",
    "event_name",
    "produced_at",
    "payload"
  ],
  "properties": {
    "event_id": {
      "type": "string",
      "description": "Уникальный идентификатор события"
    },
    "event_version": {
      "type": "integer",
      "const": 0,
      "description": "Версия события"
    },
    "event_name": {
      "type": "string",
      "const": "ExerciseCompletedMoreThenTenTimes",
      "description": "Название события"
    },
    "produced_at": {
      "type": "string",
      "format": "date-time",
      "description": "Дата и время создания события"
    },
    "payload": {
      "type": "object",
      "required": [
        "exercise_id",
        "title",
        "author_id",
        "candidate_id"
      ],
      "properties": {
        "exercise_id": {
          "type": "string",
          "description": "ID задания"
        },
        "title": {
          "type": "string",
          "description": "Название задания"
        },
        "author_id": {
          "type": "string",
          "description": "ID автора задания"
        },
        "candidate_id": {
          "type": "string",
          "description": "ID кандидата, который выполнил задание"
        }
      },
      "additionalProperties": false
    }
  },
  "additionalProperties": false
}
```
## Переделываю формальные связи `async -> sync` и `sync -> asycn`

* Из всех своих связей после разбора домашки я переделал стриминг созданные/обновленных задания из сервиса заданий в сервис найма.
Изначально был только асинхронный стриминг задания, теперь 2 стриминга один асинхронный один синхронный, поэтому описываю переход формальной связи "Стриминг обновленного задания" из асинхронной в синхронную

1. Выбираю модель `pull/push`: Выбираю `push` модель: при назначении задания на кандидата нам нужно сразу обновить задание в сервисе найма
2. Добавляю endpoint `api/v0/exercise` на стороне потребителя, чтобы менеджмент мог засылать задания в найм
3. Отрубаю продьюсера, который засылал задания. Вместо этого, засылаю задания на эндпоинт.
Получится, что старые заданая потребитель дообработает с остатков в консьюмере (не потеряем старые данные), а новые задания зашлются на эндпоинт (будет слать новые данные)
4. Смотрим события в консмьюмере, когда они заканчиваются удаляем его
5. Чистим метрики, графану, код, таблицы в базе

* Представим что нужно в обратную сторону миграцию сделать: `sync -> async`. Вместо синхронного вызова эндпоинта делаем событие

1. Добавляю событие в `schema registry`, чтобы продьюсер и консьюмер имели одинаковое представление о событии
2. Написать код консьюмера для правильной обработки события
3. Написать код прольюсера для отправки события
4. Добавить фиче флаг для включения/отключения отправки синхронного вызова и отрубаем синхронную коммуникацию
5. Чистим код

## Переделываю функциональные связи `async -> sync` и `sync -> asycn`

* У меня бизнес событие о том что задание выполнили верно из найма в сервис заданий сделано синхронно,
тк я думал что для максимальной консистентности нам нужен здесь синхронный вызов, чтобы решить проблему с тем,
что ребятки делают легкий задания и читерят, но после разбора подумал, что по идее можно сделать и `async`,
типа все равно есть гэп между событием и тем что кто-то сядет задание исправлять, а консьюмер сервиса заданий по идее не должен захлебнуться,
все кроме 1 коммуникации из него `async`, так что должно быть нормас и с async `связью`.
Поэтому представим, что сначала я переделываю функциональную связь `async -> sync`:

1. На стороне консьюмера (сервис заданий) делаем эндпоинт `api/conplicate_exercise` для усложнения задания (мы стримим что задание выполнили верно и если там больше 10 то усложняем)
2. На стороне продьюсера убираем отправку события и добавляем синхронный вызов
3. Ждем пока не обработаются все события в брокере, чтобы ниче не потерять
4. Отрубаем код связанный с асинхронной коммуникацией, удаляем топики и тд

* А потом решаю переделать обратно: `sync -> async`

1. Добавляем новое событие `ExerciseCompletedMoreThenTenTimes` в schema registry
2. В сервисе заданий делаем пустого консьюмера, проверяем что коммуникация работает
3. Генерим событие и продьюсим его
4. Проверяем что все работает
5. Допиливаем бизнес логику в консьюмере, делаеи фиче флаг, удаляем старую бизнес логику
6. Очищаем систему от старой коммуникации

## Миграция под новые требования

* Миграция US-160. По идее задевается и `sync` (задание обновлено) и `async` (задание создано) и надо делать также описание для `sync`, но я сделаю только для `async`
1. Добавляем schema registry и нулевую версию события (старое событие)
2. Добавляем в schema registry новое событие
3. В консьюмере добавляю обработку нового события 
4. Продьюсим новое соботие по новой схеме
5. Удаляем продьюсинг старой версии события
6. Ждем пока обработаются все старые события
7. Чистим код

* Миграция US-170. Переделываем событие стиминга менеджеров из сервиса заданий в найм (все то же самое что в 160 по идее, тоже формальная связь)
1. Добавляем schema registry и нулевую версию события (старое событие)
2. Добавляем в schema registry новое событие
3. В консьюмере добавляю обработку нового события 
4. Продьюсим новое соботие по новой схеме
5. Удаляем продьюсинг старой версии события
6. Ждем пока обработаются все старые события
7. Чистим код

## Способы решения проблем вокруг бонусов
Проблемы начисления/списания бонусов крутятся вокрут рейтинга заданий, потому что мы отвечаем за актуальность рейтинга и соответственно
за то СКОЛЬКО денег начислится. А как начислится это уже не наша проблема тк этим занимается сторонний фин сервис

А связь с рейтингом синхронная какие тут проблемы? Ну возможно я ослеп да и не вижу но я НЕ ВИЖУ. 

![image](./meme/нет_проблем.jpeg)

![image](./meme/кит.jpeg)

![мой кит](./meme/ма_кит.jpg)

![любимая книга кек нет](./meme/любимая_книга.jpg)

![go топ (нет)](./meme/топ_яп_(нет).jpg)

